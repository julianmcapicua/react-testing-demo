schema {
    query: query_root
    mutation: mutation_root
    subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
    """
    measured in seconds
    """
    ttl: Int! = 60
    """
    refresh the cache entry
    """
    refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _is_null: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

"""
mutation root
"""
type mutation_root {
    """
    delete data from the table: "test"
    """
    delete_test(
        """
        filter the rows which have to be deleted
        """
        where: test_bool_exp!
    ): test_mutation_response
    """
    delete single row from the table: "test"
    """
    delete_test_by_pk(id: Int!): test
    """
    insert data into the table: "test"
    """
    insert_test(
        """
        the rows to be inserted
        """
        objects: [test_insert_input!]!
        """
        on conflict condition
        """
        on_conflict: test_on_conflict
    ): test_mutation_response
    """
    insert a single row into the table: "test"
    """
    insert_test_one(
        """
        the row to be inserted
        """
        object: test_insert_input!
        """
        on conflict condition
        """
        on_conflict: test_on_conflict
    ): test
    """
    update data of the table: "test"
    """
    update_test(
        """
        increments the numeric columns with given value of the filtered values
        """
        _inc: test_inc_input
        """
        sets the columns of the filtered rows to the given values
        """
        _set: test_set_input
        """
        filter the rows which have to be updated
        """
        where: test_bool_exp!
    ): test_mutation_response
    """
    update single row of the table: "test"
    """
    update_test_by_pk(
        """
        increments the numeric columns with given value of the filtered values
        """
        _inc: test_inc_input
        """
        sets the columns of the filtered rows to the given values
        """
        _set: test_set_input
        pk_columns: test_pk_columns_input!
    ): test
}

"""
column ordering options
"""
enum order_by {
    """
    in ascending order, nulls last
    """
    asc
    """
    in ascending order, nulls first
    """
    asc_nulls_first
    """
    in ascending order, nulls last
    """
    asc_nulls_last
    """
    in descending order, nulls first
    """
    desc
    """
    in descending order, nulls first
    """
    desc_nulls_first
    """
    in descending order, nulls last
    """
    desc_nulls_last
}

type query_root {
    """
    fetch data from the table: "test"
    """
    test(
        """
        distinct select on columns
        """
        distinct_on: [test_select_column!]
        """
        limit the number of rows returned
        """
        limit: Int
        """
        skip the first n rows. Use only with order_by
        """
        offset: Int
        """
        sort the rows by one or more columns
        """
        order_by: [test_order_by!]
        """
        filter the rows returned
        """
        where: test_bool_exp
    ): [test!]!
    """
    fetch aggregated fields from the table: "test"
    """
    test_aggregate(
        """
        distinct select on columns
        """
        distinct_on: [test_select_column!]
        """
        limit the number of rows returned
        """
        limit: Int
        """
        skip the first n rows. Use only with order_by
        """
        offset: Int
        """
        sort the rows by one or more columns
        """
        order_by: [test_order_by!]
        """
        filter the rows returned
        """
        where: test_bool_exp
    ): test_aggregate!
    """
    fetch data from the table: "test" using primary key columns
    """
    test_by_pk(id: Int!): test
}

type subscription_root {
    """
    fetch data from the table: "test"
    """
    test(
        """
        distinct select on columns
        """
        distinct_on: [test_select_column!]
        """
        limit the number of rows returned
        """
        limit: Int
        """
        skip the first n rows. Use only with order_by
        """
        offset: Int
        """
        sort the rows by one or more columns
        """
        order_by: [test_order_by!]
        """
        filter the rows returned
        """
        where: test_bool_exp
    ): [test!]!
    """
    fetch aggregated fields from the table: "test"
    """
    test_aggregate(
        """
        distinct select on columns
        """
        distinct_on: [test_select_column!]
        """
        limit the number of rows returned
        """
        limit: Int
        """
        skip the first n rows. Use only with order_by
        """
        offset: Int
        """
        sort the rows by one or more columns
        """
        order_by: [test_order_by!]
        """
        filter the rows returned
        """
        where: test_bool_exp
    ): test_aggregate!
    """
    fetch data from the table: "test" using primary key columns
    """
    test_by_pk(id: Int!): test
}

"""
columns and relationships of "test"
"""
type test {
    id: Int!
}

"""
aggregated selection of "test"
"""
type test_aggregate {
    aggregate: test_aggregate_fields
    nodes: [test!]!
}

"""
aggregate fields of "test"
"""
type test_aggregate_fields {
    avg: test_avg_fields
    count(columns: [test_select_column!], distinct: Boolean): Int!
    max: test_max_fields
    min: test_min_fields
    stddev: test_stddev_fields
    stddev_pop: test_stddev_pop_fields
    stddev_samp: test_stddev_samp_fields
    sum: test_sum_fields
    var_pop: test_var_pop_fields
    var_samp: test_var_samp_fields
    variance: test_variance_fields
}

"""
aggregate avg on columns
"""
type test_avg_fields {
    id: Float
}

"""
Boolean expression to filter rows from the table "test". All fields are combined with a logical 'AND'.
"""
input test_bool_exp {
    _and: [test_bool_exp!]
    _not: test_bool_exp
    _or: [test_bool_exp!]
    id: Int_comparison_exp
}

"""
unique or primary key constraints on table "test"
"""
enum test_constraint {
    """
    unique or primary key constraint
    """
    test_pkey
}

"""
input type for incrementing numeric columns in table "test"
"""
input test_inc_input {
    id: Int
}

"""
input type for inserting data into table "test"
"""
input test_insert_input {
    id: Int
}

"""
aggregate max on columns
"""
type test_max_fields {
    id: Int
}

"""
aggregate min on columns
"""
type test_min_fields {
    id: Int
}

"""
response of any mutation on the table "test"
"""
type test_mutation_response {
    """
    number of rows affected by the mutation
    """
    affected_rows: Int!
    """
    data from the rows affected by the mutation
    """
    returning: [test!]!
}

"""
on conflict condition type for table "test"
"""
input test_on_conflict {
    constraint: test_constraint!
    update_columns: [test_update_column!]! = []
    where: test_bool_exp
}

"""
Ordering options when selecting data from "test".
"""
input test_order_by {
    id: order_by
}

"""
primary key columns input for table: test
"""
input test_pk_columns_input {
    id: Int!
}

"""
select columns of table "test"
"""
enum test_select_column {
    """
    column name
    """
    id
}

"""
input type for updating data in table "test"
"""
input test_set_input {
    id: Int
}

"""
aggregate stddev on columns
"""
type test_stddev_fields {
    id: Float
}

"""
aggregate stddev_pop on columns
"""
type test_stddev_pop_fields {
    id: Float
}

"""
aggregate stddev_samp on columns
"""
type test_stddev_samp_fields {
    id: Float
}

"""
aggregate sum on columns
"""
type test_sum_fields {
    id: Int
}

"""
update columns of table "test"
"""
enum test_update_column {
    """
    column name
    """
    id
}

"""
aggregate var_pop on columns
"""
type test_var_pop_fields {
    id: Float
}

"""
aggregate var_samp on columns
"""
type test_var_samp_fields {
    id: Float
}

"""
aggregate variance on columns
"""
type test_variance_fields {
    id: Float
}
